---
title: "NOMS-Q1: Mental Health"
author: "Cristin Young"
format: docx
editor: visual
---

# TO DO
- flip colors on bar blot!!
- dot and arrow plot: if you came in with a 1, you average X on follow-up
- go through main study questions across the board


# NOMS scoring

The NOMS score and subscales seek to measure to what extent caregivers/parents or youths report improved mental health, daily life functioning, well-being, or social connectedness after receiving an intevention. An **increase** in score indicates a positive outcome. There are no benchmarks or clinical cutoffs established for NOMS scoring - if the follow-up assessment score is higher than the initial score, a positive outcome is indicated.

```{r, reading_in_data}
#| echo: false
#| warning: false
#| message: false
#| include: false
library(readr)
library(tidyverse)
library(readxl)
library(zoo)
library(ggridges)
library(janitor)

# dealing with crazy header rows
noms_child_raw <- read_xlsx("/Users/cristin/Dropbox/Data/eInsight Exports/Individual Assessments/NOMS-child.xlsx", na = c("-", "", "NA", "N/A"), col_names = FALSE) 
h1 <- unlist(noms_child_raw[1, ], use.names = FALSE)           # question text row
h2 <- unlist(noms_child_raw[2, ], use.names = FALSE)           # subheaders
h1_ff <- na.locf(h1, na.rm = FALSE)                 # carries last non-NA to the right
h1_ff <- str_squish(h1_ff)
new_names <- ifelse(
  is.na(h1_ff) | h1_ff == "",
  h2,                                  # keep subheader only
  paste(h1_ff, h2, sep = " - ")        # combine when applicable
)
new_names <- janitor::make_clean_names(new_names)
noms_child <- noms_child_raw[-c(1, 2), ]
names(noms_child) <- new_names
noms_child <- noms_child %>%
  select(where(~ !all(is.na(.))))

noms_self_raw <- read_xlsx("/Users/cristin/Dropbox/Data/eInsight Exports/Individual Assessments/NOMS-self_report.xlsx", na = c("-", "", "NA", "N/A"), col_names = FALSE)
h1 <- unlist(noms_self_raw[1, ], use.names = FALSE)           # question text row
h2 <- unlist(noms_self_raw[2, ], use.names = FALSE)           # subheaders
h1_ff <- na.locf(h1, na.rm = FALSE)                 # carries last non-NA to the right
h1_ff <- str_squish(h1_ff)
new_names <- ifelse(
  is.na(h1_ff) | h1_ff == "",
  h2,                                  # keep subheader only
  paste(h1_ff, h2, sep = " - ")        # combine when applicable
)
new_names <- janitor::make_clean_names(new_names)
noms_self <- noms_self_raw[-c(1, 2), ]
names(noms_self) <- new_names
noms_self <- noms_self %>%
  select(where(~ !all(is.na(.))))
```

The following data answers the follow study sub-questions:

-   **3.03: "To what extent did parents/caregivers report improved mental health for themselves and their child after receiving the intervention?"**

-   **3.04: "To what extent did the youth report improved mental health after receiving the intervention?"**

## Mental health

### CHILD

Range: 1-5

Sum = Q1.

Use the `pairs_primary_long` data frame to compute scores. The following had a positive outcome:

```{r, long_df}
#| echo: false
#| warning: false
#| message: false
#| include: false

#make sure columns are numeric
#add a total score column
#add a column for if there was any missing data, in case we want to exclude those rows later
#make sure it's date formatted and get rid of the weird dates before 2024 for now
noms_child <- noms_child %>% 
  mutate(across(ends_with("_score"), ~ as.numeric(.))) %>% 
  rowwise() %>% 
  mutate(any_missing_q1x = any(is.na(c_across(matches("^(q1|x).*_score$")))),
         total_score = sum(c_across(matches("^(q1|x).*_score$")), na.rm = TRUE)) %>% 
  ungroup %>% 
  mutate(
    date_completed = as.Date(date_completed),
    row_id = row_number()                # stable row id for disambiguation
  ) %>% 
  filter(date_completed <= Sys.Date(),     #date of running the code
         date_completed >= "2023-01-01")   #date to filter out random issue dates   

#pivot long to get individual question scores too
noms_child_long <- noms_child %>% 
  pivot_longer(
    cols = matches("^(q1|x).*_score$"),
    names_to = "question",
    values_to = "score"
  ) %>% 
  mutate(score = as.numeric(score))

#pair per question
paired_outcomes_child <- noms_child_long %>% 
  group_by(system_id, question) %>% 
  arrange(date_completed, .by_group = TRUE) %>% 
  mutate(
    days_since_initial = as.integer(date_completed - first(date_completed)),
    initial_date = first(date_completed),
    initial_score = first(score)
  ) %>% 
  # flagging follow-ups
  mutate(
    is_within3 = days_since_initial <= 3 & days_since_initial >= 0,
    is_after3 = days_since_initial >3
  )

# review queue
review_queue_long <- paired_outcomes_child %>% 
  filter(is_within3) %>% 
  transmute(
    system_id, question,
    issue = "followup_within_3_days",
    initial_date,
    candidate_date = date_completed,
    candidate_score = score,
    days_since_initial
  )

# paired data
pairs_primary_long <- paired_outcomes_child %>% 
  filter(is_after3) %>% 
  slice_tail(n = 1) %>% 
  transmute(
    system_id, question,
    initial_date,
    initial_score,
    follow_up_date = date_completed,
    follow_up_score = score,
    days_since_initial
  )

# ones without follow-up
no_followup_long <- paired_outcomes_child %>% 
  ungroup() %>% 
  summarise(has_followup = any(is_after3), .by = c(system_id, question)) %>% 
  filter(!has_followup)
```

```{r}
#| echo: false
#| warning: false
#| message: false
pairs_primary_long_q1 <- pairs_primary_long %>% 
  filter(question == "q1_how_would_you_rate_your_child_s_overall_mental_health_right_now_score")

#tabyl(pairs_primary_long_q1$initial_score)
#tabyl(pairs_primary_long_q1$follow_up_score)

# 8) compute differences in f/u and initial scores
score_diff_child_q1 <- pairs_primary_long_q1 %>% 
  mutate(score_change = follow_up_score - initial_score,
         positive_outcome = ifelse(follow_up_score > initial_score, 1, 0))

# 9) summary stats
summary_stats_child_q1 <- score_diff_child_q1 %>% 
  ungroup() %>% 
  summarise(
    mean_diff = mean(score_change, na.rm = TRUE),
    median_diff = median(score_change, na.rm = TRUE),
    sd_diff = sd(score_change, na.rm = TRUE),
    n = sum(!is.na(score_change))
  )

tabyl(score_diff_child_q1$positive_outcome)  
```

Plot it.

```{r}
#| echo: false
#| warning: false
#| message: false
q1_child_score_long <- pairs_primary_long_q1 %>%
  ungroup() %>% 
  select(system_id, initial_score, follow_up_score) %>% 
  pivot_longer(
    cols = c(initial_score, follow_up_score),
    names_to = "score_type",
    values_to = "score_value"
  ) %>%
  mutate(
    score_type = recode(score_type,
                        "initial_score" = "Initial",
                        "follow_up_score" = "Follow-up")
  )

# Plot
child_q1_plot <- ggplot(q1_child_score_long, aes(x = score_value, fill = score_type)) +
  geom_bar(
    #binwidth = 1, 
    position = position_dodge2(preserve = "single", padding = 0.01),
    width = 0.8,
    alpha = 0.8) +
  scale_fill_manual(
    values = c("Initial" = "#8A8C8E", "Follow-up" = "#BBDB49"),
    labels = c("Initial", "Follow-up")
  ) +
  scale_y_continuous(expand = c(0,0))+
  labs(x = "Measure: Q1 Score (1-5)", 
       y = "Count",
       title = "Distribution of Initial and Follow-up Scores, NOMS Child Q1") +
  theme_minimal()+
  theme(
     axis.title = element_text(size = 9),
     axis.text = element_text(size = 9),
     panel.grid.major = element_blank(),
     panel.grid.minor.x = element_blank(),
     axis.line.x = element_line(color = "lightgrey", linewidth = 0.5),
     legend.position = "inside",
     legend.justification = c("left", "top"),
     legend.title = element_blank(),
     legend.text = element_text(size = 8),
     plot.margin = margin(5, 5, 5, 5))  
  
child_q1_plot
```

#### Summary stats

The average, median, and SD at initial and discharge time points were:

```{r}
#| echo: false
#| warning: false
#| message: false
# summary stats by score type
summary_stats_child_q1 <- q1_child_score_long %>% 
  group_by(score_type) %>% 
  summarise(
    mean_score = mean(score_value, na.rm = TRUE), 
    median_score = median(score_value, na.rm = TRUE),
    sd_score = sd(score_value, na.rm = TRUE), 
    n = sum(!is.na(score_value))
  )

summary_stats_child_q1

```

The percent of those who selected ratings of 4 or higher (excellent or very good) across Q1 at initial and discharge time points were:

```{r}
#| echo: false
#| warning: false
#| message: false
# % of those who selected 4 or higher on question 1
tab5 <- pairs_primary_long_q1 %>% 
  ungroup() %>% 
  summarise(
    initial_4_5 = round(100 * (mean(initial_score[!is.na(initial_score)]  %in% c(4,5), na.rm = TRUE)), 2),
    followup_4_5 = round(100 * (mean(follow_up_score[!is.na(follow_up_score)]  %in% c(4,5), na.rm = TRUE)), 2)
  )

tab5
```

### SELF

Range: 1-5

Sum = Q1

Use the `pairs_primary_long` data frame to compute scores. The following had a positive outcome:

```{r, self_long_df}
#| echo: false
#| warning: false
#| message: false
#| include: false

#make sure columns are numeric
#add a total score column
#add a column for if there was any missing data, in case we want to exclude those rows later
#make sure it's date formatted and get rid of the weird dates before 2024 for now
noms_self <- noms_self %>% 
  mutate(across(ends_with("_score"), ~ as.numeric(.))) %>% 
  rowwise() %>% 
  mutate(any_missing_q1x = any(is.na(c_across(matches("^(q1|x).*_score$")))),
         total_score = sum(c_across(matches("^(q1|x).*_score$")), na.rm = TRUE)) %>% 
  ungroup %>% 
  mutate(
    date_completed = as.Date(date_completed),
    row_id = row_number()                # stable row id for disambiguation
  ) %>% 
  filter(date_completed <= Sys.Date(),     #date of running the code
         date_completed >= "2023-01-01")   #date to filter out random issue dates   

#pivot long to get individual question scores too
noms_self_long <- noms_self %>% 
  pivot_longer(
    cols = matches("^(q1|x).*_score$"),
    names_to = "question",
    values_to = "score"
  ) %>% 
  mutate(score = as.numeric(score))

#pair per question
paired_outcomes_self <- noms_self_long %>% 
  group_by(client_system_id, question) %>% 
  arrange(date_completed, .by_group = TRUE) %>% 
  mutate(
    days_since_initial = as.integer(date_completed - first(date_completed)),
    initial_date = first(date_completed),
    initial_score = first(score)
  ) %>% 
  # flagging follow-ups
  mutate(
    is_within3 = days_since_initial <= 3 & days_since_initial >= 0,
    is_after3 = days_since_initial >3
  )

# review queue
review_queue_long_self <- paired_outcomes_self %>% 
  filter(is_within3) %>% 
  transmute(
    client_system_id, question,
    issue = "followup_within_3_days",
    initial_date,
    candidate_date = date_completed,
    candidate_score = score,
    days_since_initial
  )

# paired data
pairs_primary_long_self <- paired_outcomes_self %>% 
  filter(is_after3) %>% 
  slice_tail(n = 1) %>% 
  transmute(
    client_system_id, question,
    initial_date,
    initial_score,
    follow_up_date = date_completed,
    follow_up_score = score,
    days_since_initial
  )

# ones without follow-up
no_followup_long_self <- paired_outcomes_self %>% 
  ungroup() %>% 
  summarise(has_followup = any(is_after3), .by = c(client_system_id, question)) %>% 
  filter(!has_followup)
```

```{r}
#| echo: false
#| warning: false
#| message: false
pairs_primary_long_q1_self <- pairs_primary_long_self %>% 
  filter(question == "q1_how_would_you_rate_your_overall_mental_health_right_now_score")

# 8) compute differences in f/u and initial scores
score_diff_self_q1 <- pairs_primary_long_q1_self %>% 
  mutate(score_change = follow_up_score - initial_score,
         positive_outcome = ifelse(follow_up_score > initial_score, 1, 0))

# 9) summary stats
summary_stats_self_q1 <- score_diff_self_q1 %>% 
  ungroup() %>% 
  summarise(
    mean_diff = mean(score_change, na.rm = TRUE),
    median_diff = median(score_change, na.rm = TRUE),
    sd_diff = sd(score_change, na.rm = TRUE),
    n = sum(!is.na(score_change))
  )

tabyl(score_diff_self_q1$positive_outcome)  
```

Plot it.

```{r}
#| echo: false
#| warning: false
#| message: false

q1_self_score_long <- pairs_primary_long_q1_self %>%
  ungroup() %>% 
  select(client_system_id, initial_score, follow_up_score) %>% 
  pivot_longer(
    cols = c(initial_score, follow_up_score),
    names_to = "score_type",
    values_to = "score_value"
  ) %>%
  mutate(
    score_type = recode(score_type,
                        "initial_score" = "Initial",
                        "follow_up_score" = "Follow-up")
  )

# Plot
self_q1_plot <- ggplot(q1_self_score_long, aes(x = score_value, fill = score_type)) +
  geom_bar(
    #binwidth = 1, 
    position = position_dodge2(preserve = "single", padding = 0.01),
    width = 0.8,
    alpha = 0.8) +
  scale_fill_manual(
    values = c("Initial" = "#8A8C8E", "Follow-up" = "#BBDB49"),
    labels = c("Initial", "Follow-up")
  ) +
  scale_y_continuous(expand = c(0,0))+
  labs(x = "Measure: Q1 Score (1-5)", 
       y = "Count",
       title = "Distribution of Initial and Follow-up Scores, NOMS Self Report Q1") +
  theme_minimal()+
  theme(
     axis.title = element_text(size = 9),
     axis.text = element_text(size = 9),
     panel.grid.major = element_blank(),
     panel.grid.minor.x = element_blank(),
     axis.line.x = element_line(color = "lightgrey", linewidth = 0.5),
     legend.position = "inside",
     legend.justification = c("left", "top"),
     legend.title = element_blank(),
     legend.text = element_text(size = 8),
     plot.margin = margin(5, 5, 5, 5))  
  
self_q1_plot
```

#### Summary stats

The average, median, and SD at initial and discharge time points were:

```{r}
#| echo: false
#| warning: false
#| message: false
# summary stats by score type
summary_stats_self_q1 <- q1_self_score_long %>% 
  group_by(score_type) %>% 
  summarise(
    mean_score = mean(score_value, na.rm = TRUE), 
    median_score = median(score_value, na.rm = TRUE),
    sd_score = sd(score_value, na.rm = TRUE), 
    n = sum(!is.na(score_value))
  )

summary_stats_self_q1
```

The percent of those who selected ratings of 4 or higher (excellent or very good) across Q1 at initial and discharge time points were:

```{r}
#| echo: false
#| warning: false
#| message: false

#tabyl(pairs_primary_long_q1_self$initial_score)
#tabyl(pairs_primary_long_q1_self$follow_up_score)

# % of those who selected 4 or higher on question 1
tab5 <- pairs_primary_long_q1_self %>% 
  ungroup() %>% 
  summarise(
    initial_4_5 = round(100 * (mean(initial_score[!is.na(initial_score)] %in% c(4,5), na.rm = TRUE)), 2),
    followup_4_5 = round(100 * (mean(follow_up_score[!is.na(follow_up_score)] %in% c(4,5), na.rm = TRUE)), 2)
  )

tab5
```

# Assumptions and data notes

For this analysis, we:

-   filtered out all dates before 2023 and after the date we ran the analysis (e.g., assessments cannot be completed in the future)

-   did not delete rows with missing data for the total score

-   dropped rows with missing `date_completed` data

-   only assessed paired data, defined by individuals with both an initial and follow-up assessment

To identify initial and follow-up assessment dates, we:

-   identified the earliest initial date per `client_system_id` and used this as the initial assessment date

-   chose a primary initial assessment date per `client_system_id`, based on the first row on that day by original data frame order

    -   any other records on the initial day go to review to identify possible duplicate initial assessments

    -   any records within +3 days of the initial date were sent to review to identify possible duplicate initial assessments

-   follow-ups were defined as all rows except the chosen primary initial date

    -   any follow-up within +3 days was sent to review and not used for pairing

-   we paired the initial score with the LAST follow-up after the +3 day window

-   we defined a positive outcome as: if follow-up score \> initial score, positive outcome == YES
